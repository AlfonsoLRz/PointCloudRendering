#pragma once

#include "stdafx.h"

#include "Geometry/3D/AABB.h"
#include "Geometry/3D/Line3D.h"
#include "Geometry/3D/Plane.h"
#include "Geometry/3D/Ray3D.h"
#include "Geometry/3D/Segment3D.h"
#include "Geometry/3D/Triangle3D.h"
#include "Geometry/3D/TriangleMesh.h"
#include "Geometry/General/BasicOperations.h"

/**
*	@file Intersections3D.h
*	@authors Alfonso López Ruiz (alr00048@red.ujaen.es)
*	@date 08/06/2019
*/

/**
*	@brief Computes the intersection between geometric entities.
*/
namespace Intersections3D
{
	/// PLANE - PLANE

	/**
	*	@brief Computes the intersection line between two planes, if any.
	*	@param result Intersection of both planes, if returned value is true. Otherwise its value is not valid.
	*/
	bool intersect(Plane& p1, Plane& p2, Line3D& result);


	/// PLANE - LINE

	/**
	*	@brief Computes the intersection point between a plane and a line.
	*	@param result Intersection point if plane and line intersect, only if returned value is true. Otherwise its value is not valid.
	*/
	bool intersect(Plane& plane, Line3D& line, vec3& result);


	/// TRIANGLE - AABB

	/**
	*	@brief Intersection test between bounding box and triangle.
	*	@return True if both entities intersect.
	*/
	bool intersect(Triangle3D& triangle, AABB& aabb);

	namespace TriangleAABB
	{
		// Data generated by Möller intersection algorithm
		struct TriangleAABBIntersData					
		{
			vec3	_v0, _v1, _v2;
			float	_min, _max, _rad;
			vec3	_normal, _edge0, _edge1, _edge2, _p, _fedge;
			vec3	_boxCenter;
			vec3	_boxRadius;
		};

		/// MÖLLER ALGORITHM.

		/**
		*	@brief Finds the minimum and maximum values of 3 floating points.
		*/
		void findMinMax(float x0, float x1, float x2, float& min, float& max);

		/**
		*	@brief Checks if a plane and the bounding box overlap.
		*/
		bool planeBoxOverlap(const vec3& normal, const vec3& vertex, const vec3& maxBox);

		/**
		*	@brief X axis test for a triangle-AABB intersection.
		*	@return false if intersection has been discarded.
		*/
		bool xAxisTest_01(TriangleAABBIntersData* data, float a, float b, float fa, float fb);

		/**
		*	@brief X axis test for a triangle-AABB intersection.
		*	@return false if intersection has been discarded.
		*/
		bool xAxisTest_2(TriangleAABBIntersData* data, float a, float b, float fa, float fb);

		/**
		*	@brief Y axis test for a triangle-AABB intersection.
		*	@return false if intersection has been discarded.
		*/
		bool yAxisTest_02(TriangleAABBIntersData* data, float a, float b, float fa, float fb);

		/**
		*	@brief Y axis test for a triangle-AABB intersection.
		*	@return false if intersection has been discarded.
		*/
		bool yAxisTest_1(TriangleAABBIntersData* data, float a, float b, float fa, float fb);

		/**
		*	@brief Z axis test for a triangle-AABB intersection.
		*	@return false if intersection has been discarded.
		*/
		bool zAxisTest_12(TriangleAABBIntersData* data, float a, float b, float fa, float fb);

		/**
		*	@brief Z axis test for a triangle-AABB intersection.
		*	@return false if intersection has been discarded.
		*/
		bool zAxisTest_0(TriangleAABBIntersData* data, float a, float b, float fa, float fb);
	};


	/// TRIANGLE - PLANE

	/**
	*	@brief Intersection test between triangle and plane.
	*	@param relation Position of triangle respect to plane.
	*	@return True if both entities intersect.
	*/
	bool intersect(Triangle3D& triangle, Plane& plane, TriangleMesh::Face::FacePlaneRelation& relation, Segment3D& segment, vec3& point);


	/// TRIANGLE - RAY

	/**
	*	@brief Intersection test between a triangle and a ray.
	*	@param point Intersection point, if triangle and ray intersects.
	*	@return True if both entities intersect.
	*/
	bool intersect(Triangle3D& triangle, Ray3D& ray, vec3& point);

	/// AABB - AABB

	/**
	*	@brief Intersection test between two axis aligned bounding boxes.
	*	@return True if both entities intersect.
	*/
	bool intersect(AABB& aabb_a, AABB& aabb_b);

	//// AABB - RAY

	/**
	*	@brief Intersection test between an axis-aligned bounding box and a ray.
	*	@return True if both entities intersect.
	*/
	bool intersect(AABB& aabb, EisemannRay& ray);
};


/// PLANE - PLANE

inline bool Intersections3D::intersect(Plane& p1, Plane& p2, Line3D& result)
{
	const vec3 p1Coeffs = p1.interceptFormCoeff(), p2Coeffs = p2.interceptFormCoeff();
	const vec3 n1 = vec3(p1Coeffs[0], p1Coeffs[1], p1Coeffs[2]);
	const vec3 n2 = vec3(p2Coeffs[0], p2Coeffs[1], p2Coeffs[2]);
	vec3 n3 = glm::cross(n1, n2);

	// Find the origin of the line
	const float det = BasicOperations::determinant3x3(n1.x, n1.y, n1.z, n2.x, n2.y, n2.z, n3.x, n3.y, n3.z);
	if (BasicOperations::equal(det, 0.0f))
	{
		result = Line3D();
		
		return false;
	}

	const float d1 = p1Coeffs[3], d2 = p2Coeffs[3];
	double x0 = (d2 * BasicOperations::determinant2x2(n1.y, n3.y, n3.z, n1.z) - d1 * BasicOperations::determinant2x2(n2.y, n3.y, n3.z, n2.z)) / det;
	double y0 = (d2 * BasicOperations::determinant2x2(n3.x, n1.x, n1.z, n3.z) - d1 * BasicOperations::determinant2x2(n3.x, n2.x, n2.z, n3.z)) / det;
	double z0 = (d2 * BasicOperations::determinant2x2(n1.x, n3.x, n3.y, n1.y) - d1 * BasicOperations::determinant2x2(n2.x, n3.x, n3.y, n2.y)) / det;

	n3 = glm::normalize(n3);		
	result = Line3D(vec3(x0, y0, z0), vec3(x0 + n3.x, y0 + n3.y, z0 + n3.z));

	return true;
}


/// PLANE - LINE

inline bool Intersections3D::intersect(Plane& plane, Line3D& line, vec3& result)
{
	const vec3 normal = plane.normal();
	const float dotDir = glm::dot(normal, line.getDest() - line.getOrigin());

	if (BasicOperations::equal(dotDir, 0.0))
	{
		result = vec3();

		return false;
	}

	const vec4 planeCoeff = plane.interceptFormCoeff();
	const float lambda = -(glm::dot(normal, line.getOrigin()) + planeCoeff[3]) / dotDir;
	result = line.getPoint(lambda);

	return true;
}


/// TRIANGLE - AABB

inline bool Intersections3D::intersect(Triangle3D& triangle, AABB& aabb)
{
	Intersections3D::TriangleAABB::TriangleAABBIntersData data;
	data._boxCenter = aabb.center();
	data._boxRadius = aabb.extent();

	// Move everything so that the boxcenter is in (0, 0, 0)
	data._v0 = triangle.getP1() - data._boxCenter;
	data._v1 = triangle.getP2() - data._boxCenter;
	data._v2 = triangle.getP3() - data._boxCenter;

	// Compute triangle edges
	data._edge0 = data._v1 - data._v0;
	data._edge1 = data._v2 - data._v1;
	data._edge2 = data._v0 - data._v2;

	// Try the 9 tests first
	data._fedge.x = std::fabsf(data._edge0.x);
	data._fedge.y = std::fabsf(data._edge0.y);
	data._fedge.z = std::fabsf(data._edge0.z);
	if (!Intersections3D::TriangleAABB::xAxisTest_01(&data, data._edge0.z, data._edge0.y, data._fedge.z, data._fedge.y)) return false;
	if (!Intersections3D::TriangleAABB::yAxisTest_02(&data, data._edge0.z, data._edge0.x, data._fedge.z, data._fedge.x)) return false;
	if (!Intersections3D::TriangleAABB::zAxisTest_12(&data, data._edge0.y, data._edge0.x, data._fedge.y, data._fedge.x)) return false;

	data._fedge.x = std::fabsf(data._edge1.x);
	data._fedge.y = std::fabsf(data._edge1.y);
	data._fedge.z = std::fabsf(data._edge1.z);
	if (!Intersections3D::TriangleAABB::xAxisTest_01(&data, data._edge1.z, data._edge1.y, data._fedge.z, data._fedge.y)) return false;
	if (!Intersections3D::TriangleAABB::yAxisTest_02(&data, data._edge1.z, data._edge1.x, data._fedge.z, data._fedge.x)) return false;
	if (!Intersections3D::TriangleAABB::zAxisTest_0(&data, data._edge1.y, data._edge1.x, data._fedge.y, data._fedge.x)) return false;

	data._fedge.x = std::fabsf(data._edge2.x);
	data._fedge.y = std::fabsf(data._edge2.y);
	data._fedge.z = std::fabsf(data._edge2.z);
	if (!Intersections3D::TriangleAABB::xAxisTest_2(&data, data._edge2.z, data._edge2.y, data._fedge.z, data._fedge.y)) return false;
	if (!Intersections3D::TriangleAABB::yAxisTest_1(&data, data._edge2.z, data._edge2.x, data._fedge.z, data._fedge.x)) return false;
	if (!Intersections3D::TriangleAABB::zAxisTest_12(&data, data._edge2.y, data._edge2.x, data._fedge.y, data._fedge.x)) return false;

	/*  First test overlap in the {x,y,z}-directions, find min, max of the triangle for each direction, and test for overlap in
		that direction -- this is equivalent to testing a minimal AABB around the triangle against the AABB */
	Intersections3D::TriangleAABB::findMinMax(data._v0.x, data._v1.x, data._v2.x, data._min, data._max);
	if (data._min > data._boxRadius.x || data._max < -data._boxRadius.x) return false;

	Intersections3D::TriangleAABB::findMinMax(data._v0.y, data._v1.y, data._v2.y, data._min, data._max);
	if (data._min > data._boxRadius.y || data._max < -data._boxRadius.y) return false;

	Intersections3D::TriangleAABB::findMinMax(data._v0.z, data._v1.z, data._v2.z, data._min, data._max);
	if (data._min > data._boxRadius.z || data._max < -data._boxRadius.z) return false;

	/* Test if the box intersects the plane of the triangle: compute plane equation of triangle as normal * x + d = 0 */
	data._normal = glm::cross(data._edge0, data._edge1);
	if (!Intersections3D::TriangleAABB::planeBoxOverlap(data._normal, data._v0, data._boxRadius)) return false;

	return true;
}

inline void Intersections3D::TriangleAABB::findMinMax(float x0, float x1, float x2, float& min, float& max)
{
	min = max = x0;
	if (x1 < min) min = x1;
	if (x1 > max) max = x1;
	if (x2 < min) min = x2;
	if (x2 > max) max = x2;
}

inline bool Intersections3D::TriangleAABB::planeBoxOverlap(const vec3& normal, const vec3& vertex, const vec3& maxBox)
{
	float v;
	vec3 vmin(0.0f), vmax(0.0f);

	for (int q = 0; q <= 2; ++q)
	{
		v = vertex[q];

		if (normal[q] > 0.0f)
		{
			vmin[q] = -maxBox[q] - v;
			vmax[q] = maxBox[q] - v;
		}
		else
		{
			vmin[q] = maxBox[q] - v;
			vmax[q] = -maxBox[q] - v;
		}
	}

	if (glm::dot(normal, vmin) > 0.0f) return false;
	if (glm::dot(normal, vmax) >= 0.0f) return true;

	return false;
}

inline bool Intersections3D::TriangleAABB::xAxisTest_01(TriangleAABBIntersData* data, float a, float b, float fa, float fb)
{
	data->_p.x = a * data->_v0.y - b * data->_v0.z;
	data->_p.z = a * data->_v2.y - b * data->_v2.z;

	if (data->_p.x < data->_p.z)
	{
		data->_min = data->_p.x; data->_max = data->_p.z;
	}
	else
	{
		data->_min = data->_p.z; data->_max = data->_p.x;
	}

	data->_rad = fa * data->_boxRadius.y + fb * data->_boxRadius.z;

	if (data->_min > data->_rad || data->_max < -data->_rad) return false;

	return true;
}

inline bool Intersections3D::TriangleAABB::xAxisTest_2(TriangleAABBIntersData* data, float a, float b, float fa, float fb)
{
	data->_p.x = a * data->_v0.y - b * data->_v0.z;
	data->_p.y = a * data->_v1.y - b * data->_v1.z;

	if (data->_p.x < data->_p.y)
	{
		data->_min = data->_p.x; data->_max = data->_p.y;
	}
	else
	{
		data->_min = data->_p.y; data->_max = data->_p.x;
	}

	data->_rad = fa * data->_boxRadius.y + fb * data->_boxRadius.z;

	if (data->_min > data->_rad || data->_max < -data->_rad) return false;

	return true;
}

inline bool Intersections3D::TriangleAABB::yAxisTest_02(TriangleAABBIntersData* data, float a, float b, float fa, float fb)
{
	data->_p.x = -a * data->_v0.x + b * data->_v0.z;
	data->_p.z = -a * data->_v2.x + b * data->_v2.z;

	if (data->_p.x < data->_p.z)
	{
		data->_min = data->_p.x; data->_max = data->_p.z;
	}
	else
	{
		data->_min = data->_p.z; data->_max = data->_p.x;
	}

	data->_rad = fa * data->_boxRadius.x + fb * data->_boxRadius.z;

	if (data->_min > data->_rad || data->_max < -data->_rad) return false;

	return true;
}

inline bool Intersections3D::TriangleAABB::yAxisTest_1(TriangleAABBIntersData* data, float a, float b, float fa, float fb)
{
	data->_p.x = -a * data->_v0.x + b * data->_v0.z;
	data->_p.y = -a * data->_v1.x + b * data->_v1.z;

	if (data->_p.x < data->_p.y)
	{
		data->_min = data->_p.x; data->_max = data->_p.y;
	}
	else
	{
		data->_min = data->_p.y; data->_max = data->_p.x;
	}

	data->_rad = fa * data->_boxRadius.x + fb * data->_boxRadius.z;

	if (data->_min > data->_rad || data->_max < -data->_rad) return false;

	return true;
}

inline bool Intersections3D::TriangleAABB::zAxisTest_12(TriangleAABBIntersData* data, float a, float b, float fa, float fb)
{
	data->_p.y = a * data->_v1.x - b * data->_v1.y;
	data->_p.z = a * data->_v2.x - b * data->_v2.y;

	if (data->_p.z < data->_p.y)
	{
		data->_min = data->_p.z; data->_max = data->_p.y;
	}
	else
	{
		data->_min = data->_p.y; data->_max = data->_p.z;
	}

	data->_rad = fa * data->_boxRadius.x + fb * data->_boxRadius.y;

	if (data->_min > data->_rad || data->_max < -data->_rad) return false;

	return true;
}

inline bool Intersections3D::TriangleAABB::zAxisTest_0(TriangleAABBIntersData* data, float a, float b, float fa, float fb)
{
	data->_p.x = a * data->_v0.x - b * data->_v0.y;
	data->_p.y = a * data->_v1.x - b * data->_v1.y;

	if (data->_p.x < data->_p.y)
	{
		data->_min = data->_p.x; data->_max = data->_p.y;
	}
	else
	{
		data->_min = data->_p.y; data->_max = data->_p.x;
	}

	data->_rad = fa * data->_boxRadius.x + fb * data->_boxRadius.y;

	if (data->_min > data->_rad || data->_max < -data->_rad) return false;

	return true;
}


/// TRIANGLE - PLANE

inline bool Intersections3D::intersect(Triangle3D& triangle, Plane& plane, TriangleMesh::Face::FacePlaneRelation& relation, Segment3D& segment, vec3& point)
{
	const vec3 pointOnPlane		= plane.getPoint(0.0f, 0.0f);
	const vec3 planeNormal		= plane.normal();
	const vec3 a				= triangle.getP1(), b = triangle.getP2(), c = triangle.getP3();
	float dot1					= glm::dot(planeNormal, triangle.getP1() - pointOnPlane);
	float dot2					= glm::dot(planeNormal, triangle.getP2() - pointOnPlane);
	float dot3					= glm::dot(planeNormal, triangle.getP3() - pointOnPlane);

	if (BasicOperations::equal(dot1, 0.0f)) dot1 = 0.0f;
	if (BasicOperations::equal(dot2, 0.0f)) dot2 = 0.0f;
	if (BasicOperations::equal(dot3, 0.0f)) dot3 = 0.0f;

	// All points above plane
	if (dot1 > 0.0f && dot2 > 0.0f && dot3 > 0.0f)
	{
		relation = TriangleMesh::Face::FacePlaneRelation::POSITIVE;

		return false;
	}

	// All points below plane
	if (dot1 < 0.0f && dot2 < 0.0f && dot3 < 0.0f)
	{
		relation = TriangleMesh::Face::FacePlaneRelation::NEGATIVE;

		return false;
	}

	// Coplanar case
	if (BasicOperations::equal((std::abs(dot1) + std::abs(dot2) + std::abs(dot3)), 0.0f))
	{
		relation = TriangleMesh::Face::FacePlaneRelation::COPLANAR;

		return true;
	}

	// Most common intersection
	vec3 point1, point2;
	Line3D line1, line2;
	bool caseA = false, caseB = false, caseC = false, caseD = true;

	if ((dot1 > 0.0f && dot2 > 0.0f && dot3 < 0.0f) || (dot1 < 0.0f && dot2 < 0.0f && dot3 > 0.0f))
	{
		line1 = Line3D(a, c); line2 = Line3D(b, c);
		caseA = true;
	}

	if ((dot2 > 0.0f && dot3 > 0.0f && dot1 < 0.0f) || (dot2 < 0.0f && dot3 < 0.0f && dot1 > 0.0f))
	{
		line1 = Line3D(b, a); line2 = Line3D(c, a);
		caseA = true;
	}

	if ((dot1 > 0.0f && dot3 > 0.0f && dot2 < 0.0f) || (dot1 < 0.0f && dot3 < 0.0f && dot2 > 0.0f))
	{
		line1 = Line3D(a, b); line2 = Line3D(c, b);
		caseA = true;
	}

	if (caseA)
	{
		intersect(plane, line1, point1);
		intersect(plane, line2, point2);

		relation = TriangleMesh::Face::FacePlaneRelation::SEGMENT_INT;
		segment = Segment3D(point1, point2);

		return true;
	}

	// Case B
	if (dot1 == 0 && ((dot2 > 0 && dot3 > 0) || (dot2 < 0 && dot3 < 0)))
	{
		point1 = a;
		caseB = true;
	}

	if (dot2 == 0 && ((dot1 > 0 && dot3 > 0) || (dot1 < 0 && dot3 < 0)))
	{
		point1 = b;
		caseB = true;
	}

	if (dot3 == 0 && ((dot2 > 0 && dot1 > 0) || (dot2 < 0 && dot1 < 0)))
	{
		point1 = c;
		caseB = true;
	}

	if (caseB)
	{
		relation = TriangleMesh::Face::FacePlaneRelation::POINT_INT;
		point = point1;
	}

	// Case C
	if (dot1 == 0 && ((dot2 > 0 && dot3 < 0) || (dot2 < 0 && dot2 > 0)))
	{
		line1 = Line3D(c, b);
		point2 = a;
		caseC = true;
	}

	if (dot2 == 0 && ((dot1 > 0 && dot3 < 0) || (dot1 < 0 && dot3 > 0)))
	{
		line1 = Line3D(a, c);
		point2 = b;
		caseC = true;
	}

	if (dot3 == 0 && ((dot1 > 0 && dot2 < 0) || (dot1 < 0 && dot2 > 0)))
	{
		line1 = Line3D(a, b);
		point2 = c;
		caseC = true;
	}

	if (caseC)
	{
		intersect(plane, line1, point1);

		relation = TriangleMesh::Face::FacePlaneRelation::SEGMENT_INT;
		segment = Segment3D(point2, point1);

		return true;
	}

	// Case D
	if (dot1 == 0 && dot2 == 0)
	{
		point1 = a; point2 = b;
		caseD = true;
	}

	if (dot2 == 0 && dot3 == 0)
	{
		point1 = b; point2 = c;
		caseD = true;
	}

	if (dot1 == 0 && dot3 == 0)
	{
		point1 = a; point2 = c;
		caseD = true;
	}

	if (caseD)
	{
		relation = TriangleMesh::Face::FacePlaneRelation::SEGMENT_INT;
		segment = Segment3D(point1, point2);

		return true;
	}

	relation = TriangleMesh::Face::FacePlaneRelation::NO_RELATION;

	return false;
}


/// TRIANGLE - RAY

inline bool Intersections3D::intersect(Triangle3D& triangle, Ray3D& ray, vec3& point)
{
	vec3 edge1, edge2, rayVector, h, s, q;
	float a, f, u, v;

	edge1		= triangle.getP2() - triangle.getP1();
	edge2		= triangle.getP3() - triangle.getP1();
	rayVector	= glm::normalize(ray.getDest() - ray.getOrigin());

	h = glm::cross(rayVector, edge2);
	a = glm::dot(edge1, h);

	if (BasicOperations::equal(a, 0.0f))				// Parallel ray case
	{
		return false;
	}

	f = 1.0f / a;
	s = ray.getOrigin() - triangle.getP1();
	u = f * glm::dot(s, h);

	if (u < 0.0f || u > 1.0f)
	{
		return false;
	}

	q = glm::cross(s, edge1);
	v = f * glm::dot(rayVector, q);

	if (v < 0.0f || ((u + v) > 1.0f))
	{
		return false;
	}

	float t = f * glm::dot(edge2, q);
	if (t > glm::epsilon<float>())
	{
		point = ray.getOrigin() + rayVector * t;

		return true;
	}

	return false;							// There is a LINE intersection but no RAY intersection
}

/// AABB - AABB

/**
*	@brief Intersection test between two axis aligned bounding boxes.
*	@return True if both entities intersect.
*/
inline bool Intersections3D::intersect(AABB& aabb_a, AABB& aabb_b)
{
	const vec3 aCenter = aabb_a.center(), aExtent = aabb_a.extent();
	const vec3 bCenter = aabb_b.center(), bExtent = aabb_b.extent();

	bool x = std::abs(aCenter.x - bCenter.x) <= (aExtent.x + bExtent.x);
	bool y = std::abs(aCenter.y - bCenter.y) <= (aExtent.y + bExtent.y);
	bool z = std::abs(aCenter.z - bCenter.z) <= (aExtent.z + bExtent.z);

	return x && y && z;			// Overlap!
}

/// AABB - RAY

inline bool Intersections3D::intersect(AABB& aabb, EisemannRay& ray)
{
	return ray.intersect(aabb);
}
